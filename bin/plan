#!/bin/bash

set -o errexit
set -o pipefail

# shellcheck source=.common.sh
source "$(dirname ${BASH_SOURCE[0]})/.common.sh"

_checkenv

cluster="${PIPELINE_CLUSTER}"

# # The two undefined variables below (master_base_sha and branch_head_sha)
# # are passed by the github-pull-request concourse resource.
# # shellcheck disable=SC2154
# changed_dirs=$(git diff-tree --no-commit-id --name-only -r $master_base_sha $branch_head_sha | grep "${PIPELINE_CLUSTER}" | awk 'BEGIN{FS=OFS="/"}/\/resources\//{NF-=1; print $3}' | sort | uniq ) || true

# log green "planning for cluster ${cluster}"
# ( set -x; kubectl config use-context "${cluster}" ) || { log red "no context found, skipping ${cluster}" && exit 1; }
# if [ -n "$changed_dirs" ]; then
#   for _f in ${changed_dirs}; do
#     namespace="$(basename ${_f})"
#     terraform_resources_path="namespaces/${cluster}/${namespace}/resources"
#     if [ -d "${terraform_resources_path}" ]; then
#       (
#       cd "${terraform_resources_path}"
#       log blue "Planning terraform resources for namespace ${namespace} in ${cluster}"
#       terraform init \
#         -backend-config="bucket=${PIPELINE_STATE_BUCKET}" \
#         -backend-config="key=${PIPELINE_STATE_KEY_PREFIX}${cluster}/${namespace}/terraform.tfstate" \
#         -backend-config="region=${PIPELINE_STATE_REGION}"
#       terraform plan \
#         -var="cluster_name=${cluster%%.*}" \
#         -var="cluster_state_bucket=${PIPELINE_CLUSTER_STATE_BUCKET}" \
#         -var="cluster_state_key=${PIPELINE_CLUSTER_STATE_KEY_PREFIX}${cluster%%.*}/terraform.tfstate"
#       )
#       # cd $OLDPWD
#     fi
#   done
# else
#   log blue "No terraform changes in this PR"
# fi


log green "applying for cluster ${cluster}"
( set -x; kubectl config use-context "${cluster}" ) || { log red "no context found, skipping ${cluster}" && exit 1; }
# log blue "applying cluster-level resources for ${cluster}"
# ( set -x; kubectl apply -f "${cluster}" ) || log blue "no global resources to apply"
for _f in ${cluster}/*; do
  if [ -d "${_f}" ]; then
    namespace="$(basename ${_f})"
    # log blue "applying resources for namespace ${namespace} in ${cluster}"
    # ( set -x; kubectl -n "${namespace}" apply -f "${_f}" )
    terraform_resources_path="namespaces/${cluster}/${namespace}/resources"
    if [ -d "${terraform_resources_path}" ]; then
      (
        cd "${terraform_resources_path}"
        log blue "applying terraform resources for namespace ${namespace} in ${cluster}"
        terraform init \
          -backend-config="bucket=${PIPELINE_STATE_BUCKET}" \
          -backend-config="key=${PIPELINE_STATE_KEY_PREFIX}${cluster}/${namespace}/terraform.tfstate" \
          -backend-config="region=${PIPELINE_STATE_REGION}"
        terraform plan \
          -var="cluster_name=${cluster%%.*}" \
          -var="cluster_state_bucket=${PIPELINE_CLUSTER_STATE_BUCKET}" \
          -var="cluster_state_key=${PIPELINE_CLUSTER_STATE_KEY_PREFIX}${cluster%%.*}/terraform.tfstate"
      )
      # cd $OLDPWD
    fi
  fi
done 
  # _ns_pruneable=$(kubectl get ns -o json | jq -r '.items[] | select(.metadata.annotations["environment.k8s.dsd.io/managed"] == "true") | .metadata.name')
  # _ns_toprune=$(echo "${_ns_pruneable}" | grep -vE '(default|kube-system|kube-public)' | grep -v "$(ls ${_c})")
  # if [ "${#_ns_toprune}" -gt 0 ]; then
  #   log red "pruning namespaces in cluster ${cluster}: $(echo ${_ns_toprune})"
  #   log blue "skipping deletion of namespaces"
  #   # for _nsp in ${_ns_toprune}; do
  #   #   ( set -x; kubectl delete namespace "${_nsp}" --grace-period=30 )
  #   # done
  # else
  #   log blue "no namespaces to prune in ${cluster}"
  # fi